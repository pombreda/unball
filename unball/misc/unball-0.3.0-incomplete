#!/usr/bin/env bash
# unball 
# by deitarion (Stephan Sokolow)
# Version 0.3.0
# Licensed under the GNU GPL
#
# Inspired by maitre's unball (http://kdelook.org/content/show.php?content=12561)
# (It would be based on it, but there was none of the old code left by the time I was done the first release)
#
# Version 1.0.0 of this script will be released when I can find no more unsupported archive formats to add.
#
# Version 0.3.0
# - Major cleaning done on the status messages displayed.
#
# Version 0.2.8
# - Fixed handling of ACE archives.
# - Fixed compatibility with systems that don't install bash in /bin
# - Switched from sed-based extension removal to internal bash functions.
#
# Version 0.2.7
# - Added recognition of PackIt (.pit) and Compact Pro archives (.cpt), MacOS Disk Images (.dmg), 
#   PAQ6 (.pq6), GCA, DGCA (.dgc), ZZip (.zz), and DAR archives, Microsoft Installers (.msi),
#   BlakHole (.bh) archives, WinRK (.rk) archives, and PartImage (.partimg) disk images.
# - Added support for rzip-compressed (.rz) files.
# - Added explicit support for CPIO files with .cp extensions, JAR files with .j extensions
#   Itsy Packages (renamed gzipped tarballs with specific contents), Python eggs (.egg)
# - Added PC-BSD Installers (.pbi), MacOS X .pkg, and .mpkg files, and Ruby gems (.gem)  to the TODO list.
#
# Version 0.2.6
# - Added support for yydecode
#
# Version 0.2.5 changes:
# - unball now silently skips common non-archives unless passed --verbose
# - Fixed the message displayed when extracting CAB files.
# - Added by-extension support for RSN (RAR containing SPC files) archives.
#
# Version 0.2.4 changes:
# - Fixed the "risk of deleting source if the 'strip extension to create target' process fails" bug.
#
# Version 0.2.3 changes:
# - Added the --samedir option.
#
# Version 0.2.2 changes:
# - Fixed a harmless bug causing the wrong message while unpacking .zip files
#   and forcing the use of the "check the headers" fallback for .cbz files.
# - Added support for sfArk files and recognition of SFPack files.
#
# Version 0.2.1 changes:
# - Added more explicit (extension) and fallback (header) entries to the list of supported formats.
# - Added some entries which will identify unsupported formats without unpacking them.
# - Added recognition and messages for CloneCD and ISO9660 CD images.
# - Corrected a TODO. "lha for UNIX" is now open source and hosted on SourceForge Japan.
# - Added a more helpful failure message to the routine which attempts to extract self-extractors without running them.
# - unball will now exit with error code 2 if the target directory is not writeable.
#
# Version 0.2.0 changes:
# - Added support for .Z (UNIX compress) files. I'm surprised I forgot about them.
# - Added support for several more "renamed zip file" formats
# - There is now support for using the "file" command as a fallback if unball
#   doesn't recognize a file's extension. (This allows unball to unpack OpenOffice
#   and KOffice documents without needing an explicit entry for them.
#
# Version 0.1.2 bugfixes:
# - Now the old abspath() is just a fallback and it will try two proven path 
#   canonicalization tools before resorting to my code.
#
# Version 0.1.1 bugfixes:
# - Works if the directory has spaces in the name (bug fixed in abspath())
# - Actually obeys the target dir specified with --dir
#
# Enhancements over maitre's script as of version 1.0.0:
# - Works with filenames containing spaces.
# - Support for a great many more formats. (In fact, more formats than most people even know of)
# - Ignores case when matching  archive extensions to programs. (I can't find any reason not to)
# - Creates containing folders as needed regardless of archive format and only when necessary. (Much better than the old method)
# - Silencing extraction tools is now centralized. (And adds support for --verbose)
# - Code is much cleaner (once you compensate for it's greater complexity)
# - Should work as a drop-in replacement for maitre's unball script.
# - Some other stuff but I can't remember what it was.
#
# TODO:
# - Figure out how to detect support for the j switch in tar and use it when available.
# - NOTE: Stampede Linux SLP packages are just specialized .tar.bz2 files renamed. Take advantage of this.
# - Decide how to best warn people away from formats like RAR due to their highly proprietary nature.
# - Figure out what PC-BSD Installers (.pbi) MacOS X .pkg, and .mpkg files, and Ruby gems (.gem)  are, internally.
# - Get around to adding ??_ (mscompress), adf (unadf or readdisk), adz (gunzip and unadf or readdisk), dms (undms or xdms),  xar, alz (unalz), sitx (Stuffit X)
# - Add support for recursively unpacking nested archives
# - Consider swapping things so that it follows the policy used by Konqueror and Nautilus (check the header first and fall back to the extension)
#    (The problem is that doing so risks running an unintended extractor. It shouldn't be a risk though since this script avoids executing given files)
# - Unsupported Self-Extractors:
#   - Figure out how to implement support for extracting MS-DOS self-extracting ZOO archives. (see `man zoo`)
#   - Look for a way to automatically extract self-extracting 7z files without running them inside wine.
#   - Consider adding a switch which enables use of UPX  decompression when applicable. (UPX is an executable packer)
# - Decide on and implement a detection method to figure out what .BIN files are. (BinHexed Archives, CD Images, Apple II ROMs, etc.)
# - Add more support for identifying disk image formats that cannot be unpacked by unball.
#
# Related TODO:
# - Look for a Linux-native method of unpacking SQX files. (Or try to write one using the info from http://www.sqx-archiver.org/)
#
# Known Bugs:
# - "Emulator BIOS - By The Seeding Savioursï¿½.rar" breaks the code which trims off file extensions.
# - Extension trimming doesn't work properly with compressed tar files

function abspath()   { realpath -s "$@" || readlink -f "$@" || pathjoin "`pwd`" "$@"; }
function exists()    { type "$@" > /dev/null 2>&1; }
function isprog()    { which "$@" > /dev/null 2>&1; }
function lower()     { tr [:upper:] [:lower:] <<< "$@"; }
function pathjoin()  { ([[ "$2" != /* ]] && echo "$1"/"$2") || echo "$2"; }
function pathsplit() { grep -Eo "[^/]*$" <<< "$@"; }
function sizeInKiB()   { `du -k "$FILE" | grep -oE "^[0-9]*"`; }

xbegin() {
	# Usage: xbegin extension filename
	CURR_LINE="$(tput setaf 3) $1	$(tput sgr0)$2"
	echo -en "$CURR_LINE"
}

xend() {
	# Usage: xend exitCode
	COLS=`tput cols`
	if [ "$1" == 0 ]; then
		printf "\r%-$(( COLS - 11))s[$(tput setaf 2)  OK  $(tput sgr0)]\n" "$CURR_LINE"
	elif [ "$2" ]; then
		printf "\r%-$(( COLS - 11))s[$(tput setaf $3) ${2:-FAIL} $(tput sgr0)]\n" "$CURR_LINE"
	else
		printf "\r%-$(( COLS - 11))s[$(tput setaf 1) ${2:-FAIL} $(tput sgr0)]\n" "$CURR_LINE"
	fi
}

xunr() { #Unrecognized file
	xbegin "??? " "$1"
	xend "100" "SKIP" "4"
}

xuns() { #Unsupported file
	DELAYEDMESSAGES="$DELAYEDMESSAGES\n$FILE is apparently a(n) $1."
	if [ "$2" == "lazy" ]; then DELAYEDMESSAGES="$DELAYEDMESSAGES Due to the rarity of this format, the author of unball lacks a test archive and was too lazy to add an untested option for it. Please send a request for the feature. It will be added in a day or two."
	elif [ "$2" == "no tool" ]; then DELAYEDMESSAGES="$DELAYEDMESSAGES At this time, the unball author knows of no Linux/BSD/UNIX-compatible extraction tool for this format."
	elif [ "$2" == "no portage tool" ]; then DELAYEDMESSAGES="$DELAYEDMESSAGES As of this writing, there is no tool in the Gentoo Portage tree which can extract such files and the author of unball is too lazy to install one manually without a request from a user."
	elif [ "$2" == "mount it" ]; then DELAYEDMESSAGES="$DELAYEDMESSAGES It's a disk image and Linux users can mount disk images using -o loop. $3"
	else DELAYEDMESSAGES="$DELAYEDMESSAGES $2"
	fi
}

function extract_cab() {
    [ "$verbose" ] && echo "Attempting to extract CAB archive. (Microsoft or InstallShield Cabinet)"
    (exists cabextract && call cabextract "" "$2") ||
    (exists unshield && call unshield "-d \"$OUTDIR\"" "$2") ||
    (echo "Unable to extract $2. Ensure that cabextract and unshield are installed." && return 1)
}

function extract_exe() {
    [ "$verbose" ] && echo "Attempting to extract EXE file without running it's untrusted executable code..."
    (exists unzip && call unzip "-d \"$OUTDIR\"" "$2") ||
    (exists unace && call unace e "$2") || #Untested for lack of a self-extracting ace file.
    (exists arj && call arj x "$2") || #Untested for lack of a self-extracting arj file.
    (exists unrar && call unrar x "$2")
    [ "`ls -1`" == "" ] && (exists lha && call lha x "$2") # Untested for lack of a self-extracting lha file.
    [ "`ls -1`" == "" ] && [ "$verbose" ] && echo "Cannot extract $2. If you are certain it is a self-extracting archive and that it does not contain malicious code, try running it inside Wine" && return 1 # Unrar and lha always say "everything's dandy" so we have to check manually.
    return 0
}

function extract_gbzip() {
    exists $1 || (echo "ERROR: Cannot find unarchiver: $1" && return 1)
    cp "$2" "$TEMPTARGET" || (echo "ERROR: Cannot create temporary copy of $2" && return 1)
    call $1 "" "$TEMPTARGET"/"`pathsplit \"$2\"`" || (echo "ERROR: Decompressor $1 failed." && return 1)
}

function extract_rpm() { 
    if exists rpm2cpio && exists cpio; then
        rpm2cpio "$2" | cpio -id || (echo "ERROR: rpm2cpio or cpio error" && return 1)
    elif exists rpm2targz && exists tar && (exists gunzip || exists gzip); then
        call rpm2targz "$2" || (echo "ERROR: Unknown rpm2targz failure" && return 1)
        TARGZ="${2%.*}.tar.gz"
        call tar xzf "$TARGZ" || (echo "ERROR: Unknown failure extracting $TARGZ" && return 1)
        call rm "$TARGZ" || (echo "ERROR: Could not remove $TARGZ" && return 1)
        unset TARGZ
    else
        echo "ERROR: RPM extraction requires either rpm2cpio with cpio, or rpm2targz with a gzip-friendly tar command."
        return 1
    fi
    return 0
}

function extract_sit() { (exists unstuff && call unstuff "--destination=." "`sed \"s@/[^/]*@../@g\" <<< \`pwd\``$2") || (echo "ERROR: Could not find Stuffit Expander" && return 1); }

function decode_binhex() { (exists uudeview && call uudeview -i "$2") || (exists unstuff && call unstuff "--destination=." "`sed \"s@/[^/]*@../@g\" <<< \`pwd\``$2") || (echo "ERROR: Could not find UUDeView or Stuffit Expander" && return 1); }
function decode_uu()  { (exists uudecode && call uudecode "" "$2") || (exists uudeview && call uudeview -i "$2") || (echo "ERROR: Could not find UUDecode or UUDeView" && return 1); }
function decode_xx()  { (exists xxdecode && call xxdecode "" "$2") || (exists uudeview && call uudeview -i "$2") || (echo "ERROR: Could not find XXDecode or UUDeView" && return 1); }
function decode_ync() { (exists ydecode && call ydecode "" "$2") || (exists yydecode && call yydecode "" "$2") ||(exists uudeview && call uudeview -i "$2") || (echo "ERROR: Could not find YDecode, yydecode,  or UUDeView" && return 1); }

# A centralized method of implementing the quiet/verbose switch.
function call() {
    if [ "$verbose" == 1 ] || [ "$1" == "gunzip" ] || [ "$1" == "bunzip" ] || [ "$1" == "cpio" ]; then
        ([ -n "$2" ] && $1 $2 "$3") || $1 "$3"
    else
	([ -n "$2" ] && $1 $2 "$3" > /dev/null 2>&1) || $1 "$3" > /dev/null 2>&1
    fi
}

# This is the best bash equivalent I can think of to Python's try/except or Java's try/catch. (I forget what Perl's version is called)
function really_extract() {
    # Usage: really_extract archive_tool arguments file targetDir
    [[ $# != 4 ]] && echo "BUG #002: Invalid number of arguments passed to really_extract()" && return 1
    
    TARGET=`pathjoin "$OUTDIR" "${3%.*}"`
    if [ -e "$TARGET" ]; then
	echo "Target dir \"$TARGET\" exists. Aborting for this file."
	return 2
    fi
    TEMPTARGET=`mktemp -td unball.XXXXXX` || return 2
    cd "$TEMPTARGET" || return 3
    exists "$1" || return 4
    ((isprog "$1" && call "$1" "$2" "$3") || ("$1" "$2" "$3")) || return 5
    
    # The check for nested tar archives
    TARTARGET="`pathsplit \"$TARGET\"`"
    if [[ "$TARGET" == *.tar ]] && [ -f "$TARTARGET" ]; then
        (tar xf "$TARTARGET" || return 5) && (rm "$TARTARGET" || return 7)
        TARGET="${TARGET%.*}"
    fi
    unset TARTARGET
    
    # If there are no more than 3 entries (including . and ..) then just move the contents
    if [ `ls -a "$TEMPTARGET" | wc -l` -le 3 ]; then
        mv * "$OUTDIR" || return 6
    else
        mv "$TEMPTARGET" "$TARGET" || return 6
    fi
    
    cd "$CURRDIR" || return 3
    [ -a "$TEMPTARGET" ] && (rmdir "$TEMPTARGET" || return 7)
    return 0
}

function extract() {
    # Usage: extract archive_tool arguments file extension description
    # Return values for really_extract:
    # 0 - Extracted OK
    # 1 - A bug trap was triggered.
    # 2 - Could not make temp dir
    # 3- Could not change directories
    # 4 - Could not find requested unarchiving tool
    # 5 - Archive tool returned an error
    # 6 - Could not move files to target dir
    # 7- Could not delete temporary files/dirs.
    [[ $# != 5 ]] && echo "BUG #001: Invalid number of arguments passed to extract()" && return 1
    CURRFILE=`abspath "$3"`
    
    xbegin "$4" "$3"
    [ $verbose ] && echo "Found $5, unballing $3..."
    really_extract "$1" "$2" "$CURRFILE" "$OUTDIR" >/dev/null 2>&1
    RETURNCODE="$?"
    if [ $RETURNCODE != 0 ]; then
        # Clean up after the failed extraction
        cd "$CURRDIR"
        rm -rf "$TEMPTARGET"
        [ $RETURNCODE == 6 ] && [ ! -f "$TARGET" ] && rm -rf "$TARGET"
        
        [ $RETURNCODE == 4 ] && echo "ERROR: Required archiving tool ($1) not found."
        [ "$verbose" ] && echo "ERROR: Could not extract $3 (Error code: $RETURNCODE)"
	xend "$RETURNCODE"
        return 1
    else
	xend 0
        return 0
    fi
}

function show_help() {
    echo "ssokolow's unball"
    echo "Usage: $0 [options] archive [archive [...]]"
    echo
    echo "Options:"
    echo " -d/--dir target      Set the target directory for extraction"
    echo " -D/--samedir target  Use the source directory as the target"
    echo " -v/--verbose         Show status output from the decompressors"
}

# ===== Start of Main Program =====
# Prep the requisite variables
CURRDIR=`pwd`
OUTDIR="$CURRDIR" # This will be changed if --dir is used.

# Jury-rig some flexibility
exists unrar || (exists rar && alias unrar="rar")
exists 7z || (exists 7za && alias 7z="7za")

# Parse the options
while [[ $1 == -* ]]; do
    case "$1" in
        -h|--help) show_help && exit 0;;
        -v|--verbose) verbose=1 && shift;;
        -d|--dir) OUTDIR="$2" && shift 2;;
	-D|--samedir) samedir=1 && shift 2;;
        --) shift && break;;
    esac
done

# If no arguments were provided, then show the help and exit.
[ $# == 0 ] && show_help && exit 1

# Check for things which could cause problems
[ ! -w "$OUTDIR" ] && echo "FATAL: unball does not have write permissions for target directory" && exit 2

# Parse the arguments and act on them
for FILE in "$@"; do
    if [ "$samedir" == 1 ]; then
	OUTDIR=`egrep -o ".*/" <<< \`abspath "$FILE"\``
    fi
    if [ -f "$FILE" ]; then
        case `lower "$FILE"` in
            # These silently ignore common formats which an "unball *" would otherwise generate an error message for.
            *.txt|*.htm|*.html|*.shtm|*.shtml) [ "$verbose" == 1 ] && echo "Skipping text/html document: $FILE";;
            *.mp3|*.ogg|*.flac|*.wav|*.shn|*.m4a|*.aac|*.ac3|*.mpc|*.wma) [ "$verbose" == 1 ] && echo "Skipping waveform audio file: $FILE";;
            *.mod|*.stm|*.s3m|*.xm|*.it|*.mo3|*.mid|*.spc|*.gym|*.vgm|*.psf|*.sid|*.nsf|*.hsd) [ "$verbose" == 1 ] && echo "Skipping non-waveform audio file: $FILE";;
            
            # The universal nested tar code would handle these, but gunzip and bunzip delete the compressed file on success.
            # ...and a lot of people don't like that so we'll use tar's built-in support for input piping.
            *.tar.bz2|*.tbz|*.tbz2) extract tar xjf "$FILE" "TBZ2" "bzipped tar archive";;
            *.tar.gz|*.tgz) extract tar xzf "$FILE" "TGZ " "gzipped tar archive";;
            *.tar.z|*.taz|*.tz) extract tar xzf "$FILE" "TAZ " "compressed tar archive";;
            
            # Let's take advantage of the fact that Stuffit Expander automatically handles BinHex and MacBinary
            *.sit|*.sit.bin|*.sit.hqx) extract extract_sit "" "$FILE" "SIT " "Stuffit archive";;
            *.sea|*.sea.bin|*.sea.hqx) extract extract_sit "" "$FILE" "SEA " "Stuffit Self-Extracting archive";;
	    *.sitx) xuns "StuffitX archive" "no portage tool";;
            
            *.7z)  extract 7z x "$FILE" "7ZIP" "7zip archive";;
            *.ace) extract unace e "$FILE" "ACE " "ace archive";; #UNTESTED for lack of an ace file.
	    *.adf) xuns "Amiga ADF disk image" "lazy";;
	    *.adz) xuns "Amiga ADZ compressed disk image" "lazy";;
	    *.alz) xuns "ALZip archive" "lazy";;
            *.ar)  extract ar            x       "$FILE" "AR? "  "Potential ar archive";; #UNTESTED
            *.arc) extract arc           x       "$FILE" "ARC " "arc archive";;
            *.arj) extract arj           "x -y"  "$FILE" "ARJ " "arj archive";;
	    *.bh)  xuns "BlakHole archive" "no tool";;
            *.bin) extract extract_sit   ""      "$FILE" "BIN " "Potential MacBinary-encoded file";;
            *.bz2) extract extract_gbzip bunzip2 "$FILE" "BZ2 " "bzip2-compressed file";;
            *.cab) extract extract_cab   ""      "$FILE" "CAB " "Microsoft or InstallShield 'cabinet'";;
            *.cbr) extract unrar         x       "$FILE" "CBR " "RAR-compressed comic bundle";;
	    *.cbz) extract unzip         "-d \"$OUTDIR\""      "$FILE" "CBZ " "ZIP-compressed comic bundle";;
	    *.ccd) xuns "CloneCD image" "mount it" "To get a Linux-compatible image, use the ccd2iso tool.";;
            *.cp|*.cpio) extract cpio "--force-local -idI" "$FILE" "CPIO" "cpio archive";;
	    *.cpt) xuns "Compact Pro (A.K.A. Compactor) archive" "no tool";;
	    *.dar) xuns "DAR archive (potentially)" "DAR is a Linux backup tool. The author of unball is unsure how difficult adding support safely would be.";;
            *.deb) extract ar x "$FILE" "DEB " "Debian Linux package";;
	    *.dgc) xuns "DGCA archive" "no tool";;
	    *.dmg) xuns "Apple MacOS X disk image" "mount it";;
            *.ear) (exists jar && extract jar xf "$FILE" "EAR " "potential Java Enterprise Archive (.ear)") || extract unzip "-d \"$OUTDIR\"" "EAR " "$FILE" "Potential Java Enterprise Archive (.ear)";;
            *.egg) extract unzip "-d \"$OUTDIR\"" "$FILE" "EGG " "Python install package (egg)";;
	    *.dms) xuns "Amiga DiskMasher-compressed disk image" "lazy";;
            *.exe) extract extract_exe "" "$FILE" "EXE " "Potential Windows self-extracting archive";; #UNTESTED (See extract_exe source)
	    *.gca) xuns "GCA archive" "no tool";;
            *.gz)  extract extract_gbzip gunzip "$FILE" "GZ  " "gzipped file";;
            *.hqx) extract decode_binhex "" "$FILE" "HQX " "BinHex-encoded file";; #UNTESTED for lack of a non-stuffit BinHex file.
            *.ipk) extract tar xzf "$FILE" "IPK " "itsy package";;
	    *.iso) xuns "ISO9660 CD or DVD image" "mount it";;
            # A jar is just a zip file with a different extension and a specific folder layout inside
            *.j|*.jar)   (exists jar && extract jar xf "$FILE" "JAR " "jar archive") || extract unzip "-d \"$OUTDIR\"" "$FILE" "JAR " "potential jar archive";;
            *.lzh | *.lha) extract lha x "$FILE" "LZH " "lzh archive";;
            *.lzo) extract lzop -x "$FILE" "LZOP" "lzop archive";;
            *.lzx) extract unlzx -x "$FILE" "LZX " "Amiga LZX archive";;
	    *.msi) xuns "Microsoft Installer package" "no tool";;
            *.pak) extract unzip "-d \"$OUTDIR\"" "$FILE" "PAK " "Potential Quake level (.pak)";;
	    *.partimg) xuns "PartImage file" "It can be restored to an empty partition using the PartImage tool.";;
	    *.pit) xuns "PackIt archive" "no tool";;
            *.pk3) extract unzip "-d \"$OUTDIR\"" "$FILE" "PK3 " "Quake 3 level (.pk3)";;
	    *.pq6) extract paq6 "" "$FILE" "PAQ6" "PAQ6 archive";;
            *.rar) extract unrar x "$FILE" "RAR " "rar archive";;
            *.rk) xuns "WinRK archive" "no tool";;
            *.rpm) extract extract_rpm "" "$FILE" "RPM " "RPM Package";;
            *.rsn) extract unrar x "$FILE" "RSN " "RAR-compressed SNES music (spc) set";;
            *.rz) extract rzip -d "$FILE" "RZ  " "rzip-compressed file";;
            *.sfark) extract sfarkxtc "" "$FILE" "SFARK" "sfArk-compressed SoundFont set";;
            *.sfpack) xuns "SFPack-compressed SoundFont set" "no tool";;
            *.sh) [ `sizeInKiB "$FILE"` -ge 512 ] && xuns "shell script" "However, it is unusually large for a shell script. It is probably a self-extracting archive. For security reasons, it was not executed automatically.";;
            *.shar) xuns "Shell Archive" "Because there is no reliable way to extract these without executing them, please run \"sh $FILE\" manually if you really want to extract it.";;
            # TODO: Figure out exactly what format *.slp files are in and call the decompressor directly.
            *.slp) extract alien -g  "$FILE" "SLP " "Stampede Linux slp package";; #Untested for lack of a .slp file
	    *.sqx) xuns "Squeez archive" "no tool";;
            *.tar) extract tar xf "$FILE" "TAR " "tar archive";;
            *.uu | *.uue) extract decode_uu "" "$FILE" "UU  " "UUEncoded file";;
            *.war) (exists jar && extract jar xf "$FILE" "WAR " "Potential Java Web Archive (.war)") || extract unzip "-d \"$OUTDIR\"" "$FILE" "WAR " "Potential Java Web Archive (.war)";;
	    *.xar) xuns "XAR file" "It's highly unlikely that $FILE is an archive, but there is an experimental archive format that uses the .xar extension. unball does not currently support it.";;
	    *.xpi) extract unzip "-d \"$OUTDIR\"" "$FILE" "XPI " "xpi install package";;
            *.xx | *.xxe) extract decode_xx "" "$FILE" "XX  " "XXEncoded file";;
            *.ync) extract decode_ync "" "$FILE" "yENC" "yEncoded file";;
            *.zip) extract unzip "-d \"$OUTDIR\"" "$FILE" "ZIP " "zip archive";;
            *.zoo) extract zoo -extract "$FILE" "ZOO " "zoo archive";;
            *.z) extract extract_gbzip uncompress "$FILE" "Z" "UNIX compressed file";; #UNTESTED (install ncompress and make a test file)
	    *.zz) xuns "ZZip archive" "no tool";;
	    *.??_) xuns "compressed file an old Windows-based installer" "It was probably created using Microsoft's compress.exe (no relation to UNIX compress)";;
            *) #echo "Unrecognized extension for $FILE. Attempting to determine type using file header..."
                #IDEA: Use a while loop, the -k option for file, and a whole lotta break statements.
                case `file -binNpr "$FILE"` in
                    "application/java-archive") (exists jar && extract jar xf "$FILE" "JAR " "jar archive") || extract unzip "-d \"$OUTDIR\"" "$FILE" "JAR " "jar archive";;
                    "application/mac-binhex40") extract decode_binhex "" "$FILE" "HQX " "BinHex-encoded file";;
		    "application/x-7z-compressed") extract 7z x "$FILE" "7ZIP" "7zip archive";;
                    "application/x-ace") extract unace e "$FILE" "ACE " "ace archive";; #UNTESTED for lack of an ace file.
                    "application/x-ar") extract ar x "$FILE" "AR  " "ar archive";;
                    "application/arj"|"application/x-arj") extract arj "x -y" "$FILE" "ARJ " "arj archive";;
                    "application/x-bcpio") extract cpio "--force-local -idI" "$FILE" "CPIO" "binary cpio archive";; #UNTESTED
                    "application/bzip2"|"application/x-bz2"|"application/x-bzip") extract extract_gbzip bunzip2 "$FILE" "BZ2 " "bzip2-compressed file";;
                    "application/cab") extract extract_cab "" "$FILE" "CAB " "Microsoft or InstallShield 'cabinet'";;
                    "application/x-compress"|"x-compress") extract extract_gbzip uncompress "$FILE" "Z" "UNIX compressed file";; #UNTESTED (install ncompress and make a test file)
                    "application/x-compressed") extract tar xzf "$FILE" "GZ  " "gzipped tar archive";;
                    "application/x-cpio") extract cpio "--force-local -idI" "$FILE" "CPIO" "cpio archive";;
                    "application/x-deb") extract ar x "$FILE" "DEB " "Debian Linux package";;
                    "application/x-dgca-compressed") xuns "DGCA archive" "no tool";;
                    "application/x-gca-compressed") xuns "GCA archive" "no tool";;
                    "application/x-gzip"|"x-gzip") extract extract_gbzip gunzip "$FILE" "GZ  " "gzipped file";;
		    "application/x-iso9660-image") xuns "ISO9660 CD or DVD image" "mount it";;
                    "application/lzh"|"application/x-lzh"|"application/x-lha"|"application/x-lzh-archive") extract lha x "$FILE" "LZH " "lzh archive";;
                    "application/x-lzop") extract lzop -x "$FILE" "LZOP" "lzop archive";;
                    "application/macbinary"|"application/x-macbinary") extract extract_sit "" "$FILE" "BIN " "MacBinary-encoded file";;
                    "application/x-rar") extract unrar x "$FILE" "RAR " "rar archive";;
                    "application/x-rpm") extract extract_rpm "" "$FILE" "RPM " "RPM Package";;
                    "application/x-shar"|"application/x-sh") [ `sizeInKiB "$FILE"` -ge 512 ] && xuns "shell script" "However, it is unusually large for a shell script. It is probably a self-extracting archive. For security reasons, it was not executed automatically.";;
                    "application/x-stuffit") extract extract_sit "" "$FILE" "SIT " "Stuffit archive";;
                    "application/x-sv4cpio") extract cpio "--force-local -idI" "$FILE" "CPIO" "SV4 cpio archive";; #UNTESTED
                    "application/x-tar"|"application/x-gtar") extract tar xf "$FILE" "TAR " "tar archive";;
                    "application/x-zip"|"application/zip") extract unzip "" "$FILE" "ZIP " "zip archive";;
                    "application/x-zoo") extract zoo -extract "$FILE" "ZOO " "zoo archive";;
                    "application/octet-stream") xuns "generic binary file" "It may be an archive but unball cannot be sure.";;
                    "application/x-uuencode"|"x-uuencode") extract decode_uu "" "$FILE" "UU  " "UUEncoded file";;
                    *) xunr "$FILE" && SKIPPED=1
			#echo "File is not an archive." && SKIPPED=1;;
                esac;;
        esac
    elif [ -e "$FILE" ]; then
	xunr "$FILE"
    	[ "$verbose" == 1 ] && echo "$FILE is not a regular file. Skipping."
    else
        echo "$FILE not found."
    fi
done

[ -n "$DELAYEDMESSAGES" ] && echo -e "$DELAYEDMESSAGES"
[ -n "$SKIPPED" ] && echo "Some of the given files were skipped because they were not archives or were in an unsupported format."
